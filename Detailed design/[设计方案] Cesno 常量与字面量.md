写在前面
================

这里是Ozelot。一个正在学习编程，希望和各位大佬一起交流学习的大学生。这是我们设计团队关于编程语言Cesno的**设计方案**，欢迎大家评论交流!

提示: 最终设计尚未决定，可能还有很多设计上的不足需要优化，故内容可能会发生变动。因为没法不加标签，我不得不打了“程序员”标签。希望没有给大家造成困扰。

注意: 因为Cesno并未制作完成，这里只记录Cesno的语法规范。正因如此，代码部分的高亮可能不能保证每一次都正确显示。如果影响了阅读，我感到十分抱歉!

----


常量
================

常量是一个不可变的固定值。可以通过`const`关键字来定义一个常量:

```c++
const int a = 10;    // 之后的 a 的值不可变
int b = a + 10;      // 这样是正确的，b 的值为 20
// a = a + 10;       // 这是错误的，a 不能再次被赋值
```

需要注意，`const`和指针一起使用时需要注意。关于这一点，请参照“Cesno 指针与引用”(链接的PLACEHOLDER)。

字面量
================

字面量是可以在编程语言中**不加上构造函数**直接进行书写的，代表了一个**类型已确定**的**常量**。这句话看起来可能很绕，不妨结合以下的例子来理解:

```c++
int a = 10 + 20;
```

这里的`10`和`20`就是一个属于`int`型(即之前所说“类型已确定”)的字面量。这里并没有通过形如`int(...)`的形式将其创建(即之前所说“不加上构造函数”)，==且也没有办法能“变更”它——没法让它看起来像`10`但值却不是`10`(所有字面量都是常量)==。

> 应该变得更加好理解一点

Cesno预置了一些常用的字面量值，也允许用户创建自己的字面量。这里将要分为几个部分说明。

常用类型字面量
----------------

这里是一些常用的类型的字面量的定义方式。如想参考详细的字面量定义方式(类型别)，请参考各类型的详细介绍。

因为存在范围问题，为方便理解，这里不写出具体正则式。每个正则表达式两边默认包含了和其他代码部分进行区分的标记，这里为了简洁不另列出。

| 类型     | 定义方式                                                     | 正则表达式                       | 示例                  |
| -------- | ------------------------------------------------------------ | -------------------------------- | --------------------- |
| `int`    | 处在`int`范围间的数字                                        | `\d+`，有范围限制                | `10`，`255`           |
| `long`   | 处在`int`之外`long`之内的数字；或是以`tl`结尾的`long`范围内的数字 | `\d+`或`\d+[Tt][Ll]`，有范围限制 | `1234567890`，`255tL` |
| `float`  | 处在IEEE的**双精度**浮动小数点数许可范围内的数字             | `\d+\.\d+`                       | `1.5`，`2.4`          |
| `bool`   | 关键字`true`和`false`                                        | `(true)|(false)`                 | `true`，`false`       |
| `char`   | 一个由一对单引号包围的UTF-8字符                              | `'.'`                            | `'a'`，`'あ'`，`'文'` |
| `string` | 一或多个个由一对双引号包围的UTF-8字符                        | `".+"`                           | `"string"`，`"world"` |

注: 当超过范围限制时，这个字面量将是(PLACEHOLDER)。

其中，数字类型和字符串类型可以通过加上前缀和后缀来表达更多含义。

### 数字类型(`int`，`float`等)

| 前缀(不区分大小写) | 含义                             | 示例         |
| ------------------ | -------------------------------- | ------------ |
| `0b`               | 表示接下来出现的数字进制为二进制 | `0b1101`     |
| `0o`               | 八进制前缀                       | `0o1357.246` |
| `0x`               | 十六进制前缀                     | `0xdecafe`   |

| 后缀(不区分大小写) | 含义                                          | 示例     |
| ------------------ | --------------------------------------------- | -------- |
| `tL`               | 表示这个数字为`long`型                        | `10tL`   |
| `tFS`              | 表示这个数字为`floatsg`型(单精度浮动小数点型) | `2.0tFS` |

### 字符串类型(`string`)

由`"`(半角双引号)包裹的部分被视作字符串的内容。

| 后缀(不区分大小写) | 含义                         | 示例      |
| ------------------ | ---------------------------- | --------- |
| `r`                | 表示这个字符串不包含转义字符 | `"\n\a"r` |

### 正则表达式类型(`regex`)

由`/`(左下划线，“左下右上”下划线)包裹的部分被视作正则表达式的内容。

正则表达式中，不需要像字符串一样把`\`进行转义。比如，你需要写一个匹配任意多的空白字符的正则表达式，只需要书写`/\s*/`即可，而不需要这样`regex("\\s*")`，虽然二者逻辑上等价。

容器字面量
----------------

Cesno有多种容器。这里只挑出较常用的几种容器的字面量写法。详细信息请转到“Cesno 容器类”(链接的PLACEHOLDER)。

Cesno所有的容器都继承自`container`。若一对由中括号(“[”和“]”)环绕的数据没有前后缀，且这对中括号不代表取下标时，Cesno将会把它认识成一个`container<any>`类的对象——毕竟没有任何额外信息来说明它内部的数据究竟是什么。

```c++
[1, 2, 3, 4]    // 这是一个 container<any> 类的字面量

int[] a = [1, 2, 3, 4, 5];    // 等号右边也是 container<any> 类的字面量
a[3]            // 这里是取下标的运算符，不是字面量
```

最简单的容器是**数组**(array)，有多种方式定义它:

```c++
int[] a = [1, 2, 3];                 // 不需要加上类型，包含隐式类型转换
int[] b = int[1, 2, 3];              // 等号右边可单独出现作为 int数组 的字面量
int[] c = array<int>(1, 2, 3);       // 定义的完整形式

// 定义一个大小为 4 的空数组
int[] d = int[capacity=4];
int[] e = array<int>(capacity=4);
```

接下来是**列表**(list)，类似于一个可变长的数组。列表的字面量为~~“数据类型+容器+`@list`关键字”~~形式；当作为赋值存在时，数据类型可省略:

```c++
list<int> a = list[1, 2, 3];

a.add(4);                 // 加入元素 4
a.remove(2);              // 删除元素 2
```

接下来是一个稍微有些特殊的容器，**元组**(tuple)。元组是一个一旦创建即不可改变的对象。元组和别的对象一样可以通过类名创建，但你也可以直接通过括号创建，它会自动推导类型。

```c++
tuple<int> a = tuple(1, 2);
tuple<int> b = (3, 4);

print(tuple(1, 2));    // 输出 (1, 2)
print((3, 4));         // 输出 (3, 4)
```

接下来是**字典**(dictionary，类名为`dict`)。字典表达一种映射关系，在有些编程语言中也被称作`map`。字典可以通过包含键值对的，被大括号包围的字面量创建；或是通过`dict`的构造器。

```c++
dict<int, float> a = {1: 0.5, 2: 1.0, 5: 2.5};
dict<int, float> b = dict(1, 0.5, 2, 1.0, 5, 2.5);

a.add(3, 0.3);            // 加入元素 3 对应 0.3
a.add(2, 0.3);            // 抛异常，因为 2 已经对应 1.0
a[2] = 0.3;               // 将 2 对应的值改为 0.3
a.remove(3);              // 删除元素 3 对应的映射

print({1: 2.4, 2: 3.6});
```

最后是**集合**(set，类名位 `set`)。集合表达“确定的一堆东西”，并且所有东西都不重复。

```c++
set<int> a = {1, 2, 3};

a.add(4);                  // 加入 4 这个元素
a.add(3);                  // 可视为无效操作，因为 3 已经在集合里了
a.add("Hello World");      // 抛异常，因为 a 是 int 类型的 set
a.remove(3);               // 删除 3 这个元素

print(set(1, 2, 3));
```

## 匿名对象字面量

匿名对象字面量通过一对大括号创建，内部包含了由**标识符**到**数据**(当然也可以是函数)的映射。它适用于有时需要给函数传递一个对象，但对象的构造函数不能一次性创建完成这个临时对象。

匿名对象字面量看起来和字典(`dict`)字面量很像，但要注意的是

```typescript
class TestClass
{
    var a;
    var b;
    
    constructor(var a) { this.a = a; }
}

function printMyTestClass(TestClass x)
{
    print(x.a, x.b);
}

void main()
{
    printMyTestClass(TestClass{a: "I am a string", b: 0.4});
}
```

